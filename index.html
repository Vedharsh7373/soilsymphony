<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SoilSymphony ‚Äì Smart Watering System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #0a0e1a;
      --bg-card: #12172b;
      --bg-elevated: #1a2035;
      --accent-green: #22c55e;
      --accent-blue: #3b82f6;
      --accent-yellow: #fbbf24;
      --accent-red: #ef4444;
      --accent-purple: #a855f7;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --border: #1e293b;
      --shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 
        'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #050810 100%);
      color: var(--text-primary);
      min-height: 100vh;
      padding: 2rem 1rem;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .header h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow);
    }

    .card-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 999px;
      font-size: 0.875rem;
      font-weight: 500;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-red);
      animation: pulse 2s infinite;
    }

    .status-dot.connected {
      background: var(--accent-green);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .metric-group {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }

    .metric {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
    }

    .metric-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .metric-subtitle {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }

    .progress-bar {
      height: 12px;
      background: var(--bg-elevated);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 1rem;
      border: 1px solid var(--border);
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent-green), var(--accent-yellow), var(--accent-red));
      transition: width 0.5s ease;
    }

    .progress-labels {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .btn-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-green), #16a34a);
      color: white;
      box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(34, 197, 94, 0.4);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover:not(:disabled) {
      background: #242d45;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .log-container {
      background: var(--bg-elevated);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 1rem;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      margin-top: 1rem;
    }

    .log-entry {
      padding: 0.25rem 0;
      color: var(--text-secondary);
    }

    .log-entry.in {
      color: var(--accent-blue);
    }

    .log-entry.out {
      color: var(--accent-green);
    }

    .log-entry.error {
      color: var(--accent-red);
    }

    .alert {
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      border-left: 4px solid;
    }

    .alert-info {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 1.5rem 0;
    }

    /* Game Styles */
    #gameCanvas {
      width: 100%;
      height: 300px;
      background: var(--bg-elevated);
      border: 2px solid var(--border);
      border-radius: 12px;
      display: block;
      cursor: pointer;
    }

    .game-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .game-stat {
      background: var(--bg-elevated);
      padding: 0.75rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      text-align: center;
    }

    .game-stat-label {
      color: var(--text-secondary);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .game-stat-value {
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.25rem;
      margin-top: 0.25rem;
    }

    .level-indicator {
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 0.75rem;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .grid {
        grid-template-columns: 1fr;
      }

      #gameCanvas {
        height: 250px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üå± SoilSymphony</h1>
      <p>Smart Arduino-Powered Plant Watering System</p>
    </div>

    <!-- Connection Alert -->
    <div class="alert alert-info" id="connectionAlert">
      <strong>üìå Setup Required:</strong> Use Chrome or Edge browser. Click "Connect Arduino" and select your serial port.
    </div>

    <!-- Music Control Panel -->
    <div style="text-align: center; margin-bottom: 1.5rem;">
      <div style="display: inline-flex; gap: 1rem; align-items: center; background: var(--bg-card); padding: 1rem 1.5rem; border-radius: 12px; border: 1px solid var(--border);">
        <button class="btn btn-secondary" id="muteBtn" style="padding: 0.5rem 1.5rem;">
          üîä Sound: ON
        </button>
        <div id="musicStatus" style="color: var(--text-secondary); font-size: 0.875rem; min-width: 300px;">
          <div>‚è∏Ô∏è No music playing</div>
          <div style="font-size: 0.75rem; opacity: 0.7; margin-top: 0.25rem;">
            Music plays automatically based on soil moisture
          </div>
        </div>
      </div>
    </div>

    <!-- Music Legend -->
    <div style="text-align: center; margin-bottom: 1.5rem; color: var(--text-secondary); font-size: 0.875rem;">
      <div style="display: inline-flex; gap: 2rem; background: var(--bg-elevated); padding: 0.75rem 1.5rem; border-radius: 8px; border: 1px solid var(--border);">
        <div><span style="color: var(--accent-green);">üíß WET</span> ‚Üí 432 Hz Meditation Music</div>
        <div><span style="color: var(--accent-red);">üî• DRY</span> ‚Üí Alert Recording</div>
      </div>
    </div>

    <!-- Main Grid -->
    <div class="grid">
      <!-- Connection Card -->
      <div class="card">
        <div class="card-title">
          üîå Connection
          <div style="margin-left: auto;">
            <span class="status-badge">
              <span class="status-dot" id="connectionDot"></span>
              <span id="connectionStatus">Disconnected</span>
            </span>
          </div>
        </div>
        
        <div class="metric-group">
          <div class="metric">
            <div class="metric-label">Serial Port</div>
            <div class="metric-value" id="portName">Not Connected</div>
            <div class="metric-subtitle">Baud Rate: 115200</div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="connectBtn">
            üîå Connect Arduino
          </button>
          <button class="btn btn-secondary" id="refreshBtn" disabled>
            üîÑ Refresh Status
          </button>
        </div>
      </div>

      <!-- Soil Moisture Card -->
      <div class="card">
        <div class="card-title">üíß Soil Moisture</div>
        
        <div class="metric">
          <div class="metric-label">Current Reading</div>
          <div class="metric-value" id="soilValue">---</div>
          <div class="metric-subtitle" id="soilState">Waiting for data...</div>
        </div>

        <div class="progress-bar">
          <div class="progress-fill" id="soilProgress"></div>
        </div>
        <div class="progress-labels">
          <span>Wet (0)</span>
          <span>Normal (512)</span>
          <span>Dry (1023)</span>
        </div>

        <div class="divider"></div>

        <div class="metric-label">Thresholds</div>
        <div class="metric-subtitle">
          Wet: &lt; 400 | Dry: &gt; 700
        </div>
      </div>

      <!-- Dry Soil Timer Card -->
      <div class="card">
        <div class="card-title">‚è∞ Dry Soil Timer</div>
        
        <div class="metric">
          <div class="metric-label">Time Until Auto-Water</div>
          <div class="metric-value" id="timerDisplay">--:--:--</div>
          <div class="metric-subtitle" id="timerStatus">Waiting for dry soil...</div>
        </div>

        <div class="divider"></div>

        <div class="metric-label">Set Timer Duration</div>
        <div style="display: flex; gap: 0.5rem; align-items: center; margin-top: 0.5rem; margin-bottom: 1rem;">
          <input 
            type="number" 
            id="hoursInput" 
            min="0" 
            max="999" 
            value="0" 
            style="width: 70px; padding: 0.5rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-elevated); color: var(--text-primary); font-size: 1rem; text-align: center;"
          />
          <span style="color: var(--text-secondary);">h</span>
          
          <input 
            type="number" 
            id="minutesInput" 
            min="0" 
            max="59" 
            value="30" 
            style="width: 70px; padding: 0.5rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-elevated); color: var(--text-primary); font-size: 1rem; text-align: center;"
          />
          <span style="color: var(--text-secondary);">m</span>
          
          <input 
            type="number" 
            id="secondsInput" 
            min="0" 
            max="59" 
            value="0" 
            style="width: 70px; padding: 0.5rem; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-elevated); color: var(--text-primary); font-size: 1rem; text-align: center;"
          />
          <span style="color: var(--text-secondary);">s</span>
        </div>

        <div class="metric-subtitle" id="timerInfo" style="text-align: center; color: var(--accent-yellow); margin-bottom: 1rem;">
          When soil is dry, pump will activate after 30 minutes
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="calibrateBtn" disabled>
            üìä Calibrate Sensor
          </button>
        </div>
      </div>
    </div>

    <!-- Plant Jump Game Card -->
    <div class="card">
      <div class="card-title">
        üéÆ Plant Jump Game - TURBO MODE
        <div style="margin-left: auto; font-size: 0.875rem; color: var(--text-secondary);">
          SPACE/Click/Tap: Jump | ‚Üì/Swipe: Duck
        </div>
      </div>
      
      <div class="level-indicator" id="levelIndicator">
        Level 1 - Welcome to the Garden
      </div>
      
      <canvas id="gameCanvas"></canvas>
      
      <div class="game-stats">
        <div class="game-stat">
          <div class="game-stat-label">Score</div>
          <div class="game-stat-value" id="gameScore">0</div>
        </div>
        <div class="game-stat">
          <div class="game-stat-label">Level</div>
          <div class="game-stat-value" id="gameLevel">1</div>
        </div>
        <div class="game-stat">
          <div class="game-stat-label">High Score</div>
          <div class="game-stat-value" id="gameHighScore">0</div>
        </div>
        <div class="game-stat">
          <div class="game-stat-label">Lives</div>
          <div class="game-stat-value" id="gameLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
        <div class="game-stat">
          <div class="game-stat-label">Speed</div>
          <div class="game-stat-value" id="gameSpeed">3.0x</div>
        </div>
        <div class="game-stat">
          <div class="game-stat-label">Status</div>
          <div class="game-stat-value" id="gameStatus" style="font-size: 0.9rem;">Ready</div>
        </div>
      </div>

      <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-elevated); border-radius: 8px; border: 1px solid var(--border);">
        <div style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
          <strong style="color: var(--accent-purple);">üéØ EXTREME CHALLENGE:</strong><br>
          ‚Ä¢ <strong>Flying Obstacles:</strong> Birds that move up and down<br>
          ‚Ä¢ <strong>Tall Barriers:</strong> Must duck or die!<br>
          ‚Ä¢ <strong>Speed Increases:</strong> Every 10 points = MUCH faster<br>
          ‚Ä¢ <strong>Power-ups:</strong> Shields üõ°Ô∏è and Speed Boosts ‚ö°<br>
          ‚Ä¢ <strong>Levels:</strong> 10 progressive difficulty stages (up to 5.5x speed!)<br>
          ‚Ä¢ <strong>3 Lives:</strong> Lose all lives = Game Over<br>
          ‚Ä¢ <strong>Mobile:</strong> Tap to jump, swipe down to duck
        </div>
      </div>
    </div>

    <!-- Log Card -->
    <div class="card">
      <div class="card-title">
        üìã System Log
        <button class="btn btn-secondary" id="clearLogBtn" style="margin-left: auto; padding: 0.5rem 1rem;">
          üóëÔ∏è Clear
        </button>
      </div>
      <div class="log-container" id="logContainer"></div>
    </div>
  </div>

  <script>
    // ==================== Audio System ====================
    
    let wetMusic = null;
    let dryAlert = null;
    let isMuted = false;
    let currentlyPlaying = null;
    let audioInitialized = false;
    let audioUnlocked = false;

    const MUSIC_URLS = {
      wet: 'https://raw.githubusercontent.com/Vedharsh7373/soilsymphony/refs/heads/main/432%20Hz%20-%20Positive%20Energy%20Meditation%20Music%20Deep%20Healing%20Music%20for%20The%20Body%20and%20Soul.mp3',
      dry: 'https://raw.githubusercontent.com/Vedharsh7373/soilsymphony/refs/heads/main/Record%20(online-voice-recorder.com).mp3'
    };

    function initAudio() {
      if (audioInitialized) return;
      
      try {
        wetMusic = new Audio();
        wetMusic.src = MUSIC_URLS.wet;
        wetMusic.loop = true;
        wetMusic.volume = 0.4;
        wetMusic.preload = 'auto';
        wetMusic.addEventListener('error', (e) => {
          console.error('Wet music error:', e);
          log('‚ùå 432 Hz music failed to load', 'error');
        });
        wetMusic.addEventListener('canplay', () => {
          log('‚úì 432 Hz music ready', 'info');
        });
        
        dryAlert = new Audio();
        dryAlert.src = MUSIC_URLS.dry;
        dryAlert.loop = true;
        dryAlert.volume = 0.9;
        dryAlert.preload = 'auto';
        dryAlert.addEventListener('error', (e) => {
          console.error('Dry alert error:', e);
          log('‚ùå Dry alert sound failed to load', 'error');
        });
        dryAlert.addEventListener('canplay', () => {
          log('‚úì Dry alert sound ready', 'info');
        });
        
        audioInitialized = true;
        log('üéµ Audio system initialized', 'info');
      } catch (error) {
        console.error('Audio init error:', error);
        log('‚ùå Audio initialization failed', 'error');
      }
    }

    function unlockAudio() {
      if (audioUnlocked) return;
      
      initAudio();
      
      if (wetMusic && dryAlert) {
        const playPromise1 = wetMusic.play();
        const playPromise2 = dryAlert.play();
        
        if (playPromise1 !== undefined) {
          playPromise1.then(() => {
            wetMusic.pause();
            wetMusic.currentTime = 0;
          }).catch(() => {});
        }
        
        if (playPromise2 !== undefined) {
          playPromise2.then(() => {
            dryAlert.pause();
            dryAlert.currentTime = 0;
          }).catch(() => {});
        }
        
        audioUnlocked = true;
        log('üîì Audio unlocked - ready to play', 'info');
      }
    }

    function playWetMusic() {
      if (isMuted || currentlyPlaying === 'wet') return;
      
      if (!audioInitialized) {
        initAudio();
      }
      
      stopAllMusic();
      
      if (wetMusic) {
        wetMusic.currentTime = 0;
        const playPromise = wetMusic.play();
        
        if (playPromise !== undefined) {
          playPromise.then(() => {
            currentlyPlaying = 'wet';
            log('üéµ Playing 432 Hz meditation music', 'info');
            updateMusicStatus();
          }).catch((error) => {
            console.error('Play error:', error);
            log('‚ö†Ô∏è Click anywhere to enable audio', 'error');
          });
        }
      }
    }

    function playDryMusic() {
      if (isMuted || currentlyPlaying === 'dry') return;
      
      if (!audioInitialized) {
        initAudio();
      }
      
      stopAllMusic();
      
      if (dryAlert) {
        dryAlert.currentTime = 0;
        const playPromise = dryAlert.play();
        
        if (playPromise !== undefined) {
          playPromise.then(() => {
            currentlyPlaying = 'dry';
            log('üîî Playing dry alert recording', 'info');
            updateMusicStatus();
          }).catch((error) => {
            console.error('Play error:', error);
            log('‚ö†Ô∏è Click anywhere to enable audio', 'error');
          });
        }
      }
    }

    function stopAllMusic() {
      if (wetMusic) {
        wetMusic.pause();
        wetMusic.currentTime = 0;
      }
      if (dryAlert) {
        dryAlert.pause();
        dryAlert.currentTime = 0;
      }
      currentlyPlaying = null;
      updateMusicStatus();
    }

    function toggleMute() {
      isMuted = !isMuted;
      if (isMuted) stopAllMusic();
      updateMuteButton();
    }

    function updateMuteButton() {
      const muteBtn = document.getElementById('muteBtn');
      if (muteBtn) {
        muteBtn.textContent = isMuted ? 'üîá Sound: OFF' : 'üîä Sound: ON';
      }
    }

    function updateMusicStatus() {
      const statusDiv = document.getElementById('musicStatus');
      if (!statusDiv) return;
      
      if (!audioUnlocked) {
        statusDiv.innerHTML = '<div style="color: var(--accent-yellow); font-weight: 600;">üîí Click anywhere to enable audio</div>';
      } else if (isMuted) {
        statusDiv.innerHTML = '<div style="color: var(--text-secondary);">üîá Audio muted</div>';
      } else if (currentlyPlaying === 'wet') {
        statusDiv.innerHTML = '<div style="color: var(--accent-green); font-weight: 600;">üéµ NOW PLAYING: 432 Hz Meditation Music</div>';
      } else if (currentlyPlaying === 'dry') {
        statusDiv.innerHTML = '<div style="color: var(--accent-red); font-weight: 600;">üîî NOW PLAYING: Dry Alert Recording</div>';
      } else {
        statusDiv.innerHTML = '<div style="color: var(--text-secondary);">‚è∏Ô∏è No music playing</div>';
      }
    }

    // ==================== Simple Dry Soil Timer ====================
    let timerDuration = 30 * 60 * 1000;
    let timerEndTime = null;
    let currentSoilState = null;
    let timerIntervalId = null;
    let hasWatered = false;

    function loadTimerDuration() {
      const savedHours = localStorage.getItem('timerHours');
      const savedMinutes = localStorage.getItem('timerMinutes');
      const savedSeconds = localStorage.getItem('timerSeconds');
      
      if (savedHours !== null) {
        document.getElementById('hoursInput').value = savedHours;
      }
      if (savedMinutes !== null) {
        document.getElementById('minutesInput').value = savedMinutes;
      }
      if (savedSeconds !== null) {
        document.getElementById('secondsInput').value = savedSeconds;
      }
      
      updateTimerDuration();
      updateTimerInfo();
    }

    function updateTimerDuration() {
      const hours = parseInt(document.getElementById('hoursInput').value) || 0;
      const minutes = parseInt(document.getElementById('minutesInput').value) || 0;
      const seconds = parseInt(document.getElementById('secondsInput').value) || 0;
      
      timerDuration = (hours * 60 * 60 * 1000) + (minutes * 60 * 1000) + (seconds * 1000);
      
      localStorage.setItem('timerHours', hours.toString());
      localStorage.setItem('timerMinutes', minutes.toString());
      localStorage.setItem('timerSeconds', seconds.toString());
      
      updateTimerInfo();
    }

    function updateTimerInfo() {
      const hours = parseInt(document.getElementById('hoursInput').value) || 0;
      const minutes = parseInt(document.getElementById('minutesInput').value) || 0;
      const seconds = parseInt(document.getElementById('secondsInput').value) || 0;
      
      let parts = [];
      if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`);
      if (minutes > 0) parts.push(`${minutes} minute${minutes !== 1 ? 's' : ''}`);
      if (seconds > 0) parts.push(`${seconds} second${seconds !== 1 ? 's' : ''}`);
      
      const timeText = parts.join(', ') || '0 seconds';
      document.getElementById('timerInfo').textContent = 
        `When soil is dry, pump will activate after ${timeText}`;
    }

    function startCountdown() {
      timerEndTime = Date.now() + timerDuration;
      hasWatered = false;
      
      if (timerIntervalId) clearInterval(timerIntervalId);
      timerIntervalId = setInterval(updateCountdownDisplay, 100);
      
      updateCountdownDisplay();
      log(`‚è±Ô∏è Countdown started - ${timerDuration / 1000}s until watering`, 'info');
    }

    function stopCountdown() {
      timerEndTime = null;
      hasWatered = false;
      
      if (timerIntervalId) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
      
      document.getElementById('timerDisplay').textContent = '--:--:--';
      document.getElementById('timerStatus').textContent = 'Waiting for dry soil...';
    }

    function updateCountdownDisplay() {
      if (!timerEndTime) return;
      
      const now = Date.now();
      const timeLeft = Math.max(0, timerEndTime - now);
      
      if (timeLeft === 0 && !hasWatered) {
        hasWatered = true;
        sendCommand('TRIGGER');
        log('üíß Timer complete - activating pump!', 'info');
        document.getElementById('timerStatus').textContent = 'üíß Watering now!';
        
        setTimeout(() => {
          stopCountdown();
        }, 2000);
        return;
      }
      
      const hours = Math.floor(timeLeft / (1000 * 60 * 60));
      const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
      
      document.getElementById('timerDisplay').textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      document.getElementById('timerStatus').textContent = 'Countdown active - will water when timer ends';
    }

    function handleSoilStateChange(newState) {
      const previousState = currentSoilState;
      currentSoilState = newState;
      
      if (newState === 'DRY' && previousState !== 'DRY') {
        if (timerDuration > 0) {
          startCountdown();
        } else {
          log('‚ö†Ô∏è Timer is set to 0 - no auto-watering', 'error');
        }
      }
      
      if (newState !== 'DRY' && previousState === 'DRY') {
        stopCountdown();
        log('‚úì Soil recovered - countdown stopped', 'info');
      }
    }

    // ==================== ENHANCED Plant Jump Game ====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game variables
    let gameRunning = false;
    let score = 0;
    let level = 1;
    let lives = 3;
    let highScore = localStorage.getItem('plantGameHighScore') || 0;
    let gameSpeed = 6;
    let baseSpeed = 6;

    // Level definitions - Much faster and more frequent obstacles
    const LEVELS = [
      { name: "Welcome to the Garden", minScore: 0, speedMultiplier: 1.0, obstacleFreq: 80 },
      { name: "Growing Pains", minScore: 20, speedMultiplier: 1.3, obstacleFreq: 70 },
      { name: "Budding Danger", minScore: 50, speedMultiplier: 1.6, obstacleFreq: 65 },
      { name: "Root of Evil", minScore: 80, speedMultiplier: 2.0, obstacleFreq: 60 },
      { name: "Thorn in the Side", minScore: 120, speedMultiplier: 2.4, obstacleFreq: 55 },
      { name: "Pestilence", minScore: 170, speedMultiplier: 2.8, obstacleFreq: 50 },
      { name: "Withering Heights", minScore: 230, speedMultiplier: 3.3, obstacleFreq: 45 },
      { name: "Photosynthesis Frenzy", minScore: 300, speedMultiplier: 3.8, obstacleFreq: 40 },
      { name: "Nitrogen Nightmare", minScore: 400, speedMultiplier: 4.5, obstacleFreq: 35 },
      { name: "GARDEN OF CHAOS", minScore: 500, speedMultiplier: 5.5, obstacleFreq: 30 }
    ];

    // Player (plant) - More responsive physics
    const player = {
      x: 80,
      y: canvas.height - 60,
      width: 30,
      height: 40,
      dy: 0,
      jumpPower: -16,
      gravity: 0.8,
      jumping: false,
      ducking: false,
      shielded: false,
      shieldTime: 0,
      speedBoost: false,
      speedBoostTime: 0
    };

    // Game objects
    let obstacles = [];
    let powerups = [];
    let particles = [];
    let obstacleTimer = 0;
    let powerupTimer = 0;

    // Obstacle types
    const OBSTACLE_TYPES = {
      ROCK: { width: 20, height: 30, color: '#94a3b8', ground: true },
      TALL: { width: 25, height: 60, color: '#64748b', ground: true },
      BIRD: { width: 35, height: 25, color: '#f59e0b', ground: false, amplitude: 50 },
      SPIKE: { width: 30, height: 40, color: '#ef4444', ground: true }
    };

    // Powerup types
    const POWERUP_TYPES = {
      SHIELD: { symbol: 'üõ°Ô∏è', color: '#3b82f6', duration: 5000 },
      SPEED: { symbol: '‚ö°', color: '#fbbf24', duration: 3000 }
    };

    document.getElementById('gameHighScore').textContent = highScore;

    function jump() {
      if (!player.jumping && !player.ducking) {
        player.dy = player.jumpPower;
        player.jumping = true;
        createParticles(player.x, player.y + player.height, '#22c55e', 5);
      }
    }

    function duck() {
      if (!player.jumping) {
        player.ducking = true;
        player.height = 20;
        player.y = canvas.height - 40;
      }
    }

    function stopDuck() {
      if (player.ducking) {
        player.ducking = false;
        player.height = 40;
        player.y = canvas.height - 60;
      }
    }

    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          life: 30,
          color: color,
          size: Math.random() * 3 + 2
        });
      }
    }

    function updateLevel() {
      for (let i = LEVELS.length - 1; i >= 0; i--) {
        if (score >= LEVELS[i].minScore) {
          if (level !== i + 1) {
            level = i + 1;
            log(`üéØ Level ${level}: ${LEVELS[i].name}`, 'info');
            createParticles(player.x + 15, player.y + 20, '#a855f7', 20);
          }
          baseSpeed = 6 * LEVELS[i].speedMultiplier;
          document.getElementById('levelIndicator').textContent = `Level ${level} - ${LEVELS[i].name}`;
          break;
        }
      }
    }

    function resetGame() {
      player.y = canvas.height - 60;
      player.height = 40;
      player.dy = 0;
      player.jumping = false;
      player.ducking = false;
      player.shielded = false;
      player.speedBoost = false;
      player.shieldTime = 0;
      player.speedBoostTime = 0;
      
      obstacles = [];
      powerups = [];
      particles = [];
      score = 0;
      level = 1;
      lives = 3;
      gameSpeed = 6;
      baseSpeed = 6;
      obstacleTimer = 0;
      powerupTimer = 0;
      
      updateGameUI();
    }

    function updateGameUI() {
      document.getElementById('gameScore').textContent = score;
      document.getElementById('gameLevel').textContent = level;
      document.getElementById('gameSpeed').textContent = baseSpeed.toFixed(1) + 'x';
      document.getElementById('gameLives').textContent = '‚ù§Ô∏è'.repeat(lives);
      document.getElementById('levelIndicator').textContent = 
        `Level ${level} - ${LEVELS[level - 1].name}`;
    }

    function startGame() {
      if (!gameRunning) {
        resetGame();
        gameRunning = true;
        document.getElementById('gameStatus').textContent = 'Playing';
        gameLoop();
      }
    }

    function loseLife() {
      lives--;
      createParticles(player.x + 15, player.y + 20, '#ef4444', 15);
      
      if (lives <= 0) {
        endGame();
      } else {
        log(`üíî Life lost! ${lives} remaining`, 'error');
        updateGameUI();
        
        // Brief invincibility
        player.shielded = true;
        player.shieldTime = Date.now() + 2000;
      }
    }

    function endGame() {
      gameRunning = false;
      document.getElementById('gameStatus').textContent = 'Game Over';
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('plantGameHighScore', highScore);
        document.getElementById('gameHighScore').textContent = highScore;
        log(`üéâ New high score: ${highScore}!`, 'info');
      }
    }

    function spawnObstacle() {
      const currentLevel = LEVELS[level - 1];
      const types = Object.keys(OBSTACLE_TYPES);
      
      // Higher levels have more variety
      let availableTypes = ['ROCK'];
      if (level >= 2) availableTypes.push('BIRD');
      if (level >= 3) availableTypes.push('TALL');
      if (level >= 5) availableTypes.push('SPIKE');
      
      const typeName = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      const type = OBSTACLE_TYPES[typeName];
      
      const obstacle = {
        x: canvas.width,
        y: type.ground ? canvas.height - type.height - 20 : canvas.height - 100,
        width: type.width,
        height: type.height,
        color: type.color,
        type: typeName,
        amplitude: type.amplitude || 0,
        phase: Math.random() * Math.PI * 2
      };
      
      obstacles.push(obstacle);
    }

    function spawnPowerup() {
      const types = Object.keys(POWERUP_TYPES);
      const typeName = types[Math.floor(Math.random() * types.length)];
      const type = POWERUP_TYPES[typeName];
      
      powerups.push({
        x: canvas.width,
        y: canvas.height - 100 - Math.random() * 80,
        width: 25,
        height: 25,
        type: typeName,
        symbol: type.symbol,
        color: type.color,
        rotation: 0
      });
    }

    function gameLoop() {
      if (!gameRunning) return;

      // Clear canvas with gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#1a2035');
      gradient.addColorStop(1, '#0a0e1a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const now = Date.now();

      // Update powerup timers
      if (player.shielded && now > player.shieldTime) {
        player.shielded = false;
      }
      if (player.speedBoost && now > player.speedBoostTime) {
        player.speedBoost = false;
      }

      // Dynamic speed based on powerup - less slow-down for more challenge
      gameSpeed = player.speedBoost ? baseSpeed * 0.7 : baseSpeed;

      // Update level
      updateLevel();

      // Player physics
      player.dy += player.gravity;
      player.y += player.dy;

      if (player.y >= canvas.height - (player.ducking ? 40 : 60)) {
        player.y = canvas.height - (player.ducking ? 40 : 60);
        player.dy = 0;
        player.jumping = false;
      }

      // Draw ground
      ctx.fillStyle = '#22c55e';
      ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

      // Draw player with effects
      if (player.shielded) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x + 15, player.y + player.height / 2, 25, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.fillStyle = player.speedBoost ? '#fbbf24' : '#22c55e';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Plant leaves (only if not ducking)
      if (!player.ducking) {
        ctx.beginPath();
        ctx.arc(player.x + 15, player.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + 5, player.y + 10, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + 25, player.y + 10, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Spawn obstacles
      const currentLevel = LEVELS[level - 1];
      obstacleTimer++;
      if (obstacleTimer > currentLevel.obstacleFreq / gameSpeed) {
        spawnObstacle();
        obstacleTimer = 0;
      }

      // Spawn powerups (more frequently now)
      powerupTimer++;
      if (powerupTimer > 200 && Math.random() < 0.03) {
        spawnPowerup();
        powerupTimer = 0;
      }

      // Update and draw obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.x -= gameSpeed;

        // Flying obstacle movement
        if (obs.type === 'BIRD') {
          obs.phase += 0.05;
          obs.y = canvas.height - 100 + Math.sin(obs.phase) * obs.amplitude;
        }

        // Draw obstacle
        ctx.fillStyle = obs.color;
        if (obs.type === 'BIRD') {
          // Draw bird
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.moveTo(obs.x, obs.y + obs.height / 2);
          ctx.lineTo(obs.x - 10, obs.y);
          ctx.lineTo(obs.x - 10, obs.y + obs.height);
          ctx.fill();
        } else if (obs.type === 'SPIKE') {
          // Draw spike
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.width / 2, obs.y);
          ctx.lineTo(obs.x, obs.y + obs.height);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.fill();
        } else {
          ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
        }

        // Collision detection
        if (!player.shielded &&
          player.x < obs.x + obs.width &&
          player.x + player.width > obs.x &&
          player.y < obs.y + obs.height &&
          player.y + player.height > obs.y
        ) {
          loseLife();
          obstacles.splice(i, 1);
          continue;
        }

        // Remove off-screen obstacles
        if (obs.x + obs.width < 0) {
          obstacles.splice(i, 1);
          score++;
          
          // Speed increase every 10 points with bigger jumps
          if (score % 10 === 0) {
            baseSpeed += 0.5;
          }
          
          updateGameUI();
        }
      }

      // Update and draw powerups
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pow = powerups[i];
        pow.x -= gameSpeed * 0.7;
        pow.rotation += 0.1;

        // Draw powerup
        ctx.save();
        ctx.translate(pow.x + pow.width / 2, pow.y + pow.height / 2);
        ctx.rotate(pow.rotation);
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pow.symbol, 0, 0);
        ctx.restore();

        // Collision with player
        if (player.x < pow.x + pow.width &&
          player.x + player.width > pow.x &&
          player.y < pow.y + pow.height &&
          player.y + player.height > pow.y
        ) {
          createParticles(pow.x, pow.y, pow.color, 10);
          
          if (pow.type === 'SHIELD') {
            player.shielded = true;
            player.shieldTime = now + POWERUP_TYPES.SHIELD.duration;
            log('üõ°Ô∏è Shield activated!', 'info');
          } else if (pow.type === 'SPEED') {
            player.speedBoost = true;
            player.speedBoostTime = now + POWERUP_TYPES.SPEED.duration;
            log('‚ö° Speed boost!', 'info');
          }
          
          powerups.splice(i, 1);
          continue;
        }

        if (pow.x + pow.width < 0) {
          powerups.splice(i, 1);
        }
      }

      // Update and draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Draw UI on canvas
      ctx.fillStyle = '#f1f5f9';
      ctx.font = 'bold 20px monospace';
      ctx.fillText(`Level ${level}`, 10, 30);
      ctx.fillText(`Score: ${score}`, 10, 55);
      
      if (player.shielded) {
        const shieldLeft = Math.ceil((player.shieldTime - now) / 1000);
        ctx.fillStyle = '#3b82f6';
        ctx.fillText(`üõ°Ô∏è ${shieldLeft}s`, canvas.width - 80, 30);
      }
      
      if (player.speedBoost) {
        const speedLeft = Math.ceil((player.speedBoostTime - now) / 1000);
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(`‚ö° ${speedLeft}s`, canvas.width - 80, 55);
      }

      requestAnimationFrame(gameLoop);
    }

    // Game controls
    canvas.addEventListener('click', () => {
      if (!gameRunning) {
        startGame();
      } else {
        jump();
      }
    });

    // Touch controls for mobile
    let touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchStartY = e.touches[0].clientY;
      if (!gameRunning) {
        startGame();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      const touchEndY = e.changedTouches[0].clientY;
      const deltaY = touchEndY - touchStartY;
      
      if (gameRunning) {
        if (Math.abs(deltaY) < 10) {
          // Tap - jump
          jump();
        } else if (deltaY > 30) {
          // Swipe down - duck
          duck();
          setTimeout(stopDuck, 300);
        }
      }
    }, { passive: false });

    let keysPressed = {};

    document.addEventListener('keydown', (e) => {
      if (keysPressed[e.code]) return;
      keysPressed[e.code] = true;

      if (e.code === 'Space') {
        e.preventDefault();
        if (!gameRunning) {
          startGame();
        } else {
          jump();
        }
      }
      
      if (e.code === 'ArrowDown') {
        e.preventDefault();
        if (gameRunning) {
          duck();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      keysPressed[e.code] = false;
      
      if (e.code === 'ArrowDown') {
        stopDuck();
      }
    });

    // ==================== Web Serial API ====================
    let port = null;
    let writer = null;
    let reader = null;
    let isReading = false;

    const connectBtn = document.getElementById('connectBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const calibrateBtn = document.getElementById('calibrateBtn');
    const clearLogBtn = document.getElementById('clearLogBtn');
    const hoursInput = document.getElementById('hoursInput');
    const minutesInput = document.getElementById('minutesInput');
    const secondsInput = document.getElementById('secondsInput');
    
    const connectionDot = document.getElementById('connectionDot');
    const connectionStatus = document.getElementById('connectionStatus');
    const portName = document.getElementById('portName');
    const soilValue = document.getElementById('soilValue');
    const soilState = document.getElementById('soilState');
    const soilProgress = document.getElementById('soilProgress');
    const logContainer = document.getElementById('logContainer');
    const connectionAlert = document.getElementById('connectionAlert');

    function log(message, type = 'info') {
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      
      const timestamp = new Date().toLocaleTimeString();
      let prefix = '‚Üí';
      if (type === 'in') prefix = '‚Üê';
      if (type === 'error') prefix = '‚ö†';
      
      entry.textContent = `[${timestamp}] ${prefix} ${message}`;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    async function connect() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported. Please use Chrome or Edge browser.');
        return;
      }

      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        log('Serial port opened at 115200 baud', 'info');

        const textEncoder = new TextEncoderStream();
        const writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
        writer = textEncoder.writable.getWriter();

        const textDecoder = new TextDecoderStream();
        const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();

        updateConnectionUI(true);
        connectionAlert.style.display = 'none';

        isReading = true;
        readLoop();

      } catch (error) {
        log(`Connection error: ${error.message}`, 'error');
      }
    }

    async function disconnect() {
      isReading = false;
      stopCountdown();

      try {
        if (reader) {
          await reader.cancel();
          await reader.releaseLock();
        }
        if (writer) {
          await writer.close();
        }
        if (port) {
          await port.close();
        }
      } catch (error) {
        console.error('Disconnect error:', error);
      }

      port = null;
      writer = null;
      reader = null;

      updateConnectionUI(false);
      log('Disconnected from Arduino', 'info');
    }

    async function readLoop() {
      let buffer = '';

      while (isReading && reader) {
        try {
          const { value, done } = await reader.read();
          if (done) break;
          
          buffer += value;
          const lines = buffer.split('\n');
          buffer = lines.pop();

          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed) {
              handleIncomingData(trimmed);
            }
          }
        } catch (error) {
          log(`Read error: ${error.message}`, 'error');
          break;
        }
      }
    }

    async function sendCommand(command) {
      if (!writer) {
        log('Not connected to Arduino', 'error');
        return;
      }

      try {
        await writer.write(command + '\n');
        log(command, 'out');
      } catch (error) {
        log(`Send error: ${error.message}`, 'error');
      }
    }

    function handleIncomingData(data) {
      log(data, 'in');

      if (data.startsWith('Soil:')) {
        const match = data.match(/Soil:\s*(\d+)/);
        if (match) {
          const value = parseInt(match[1]);
          soilValue.textContent = value;
          
          const percentage = (value / 1023) * 100;
          soilProgress.style.width = percentage + '%';
        }

        if (data.includes('STATE:WET')) {
          soilState.textContent = 'üíß Wet - No watering needed';
          soilState.style.color = 'var(--accent-green)';
          playWetMusic();
          handleSoilStateChange('WET');
        } else if (data.includes('STATE:DRY')) {
          soilState.textContent = 'üî• Dry - Watering recommended';
          soilState.style.color = 'var(--accent-red)';
          playDryMusic();
          handleSoilStateChange('DRY');
        }
      }

      if (data === 'TRIGGERED') {
        log('üíß Watering cycle started', 'info');
      } else if (data === 'DONE') {
        log('‚úì Watering cycle completed', 'info');
      }
    }

    function updateConnectionUI(connected) {
      if (connected) {
        connectionDot.classList.add('connected');
        connectionStatus.textContent = 'Connected';
        portName.textContent = 'Arduino (115200)';
        connectBtn.textContent = 'üîå Disconnect';
        connectBtn.classList.remove('btn-primary');
        connectBtn.classList.add('btn-secondary');
        
        refreshBtn.disabled = false;
        calibrateBtn.disabled = false;
      } else {
        connectionDot.classList.remove('connected');
        connectionStatus.textContent = 'Disconnected';
        portName.textContent = 'Not Connected';
        connectBtn.textContent = 'üîå Connect Arduino';
        connectBtn.classList.add('btn-primary');
        connectBtn.classList.remove('btn-secondary');
        
        refreshBtn.disabled = true;
        calibrateBtn.disabled = true;
        
        soilValue.textContent = '---';
        soilState.textContent = 'Waiting for data...';
        soilProgress.style.width = '0%';
      }
    }

    // Event Listeners
    connectBtn.addEventListener('click', async () => {
      if (port) {
        await disconnect();
      } else {
        await connect();
      }
    });

    refreshBtn.addEventListener('click', () => {
      sendCommand('STATUS');
    });

    calibrateBtn.addEventListener('click', () => {
      sendCommand('CALIBRATE');
      log('Starting calibration...', 'info');
    });

    hoursInput.addEventListener('change', updateTimerDuration);
    minutesInput.addEventListener('change', updateTimerDuration);
    secondsInput.addEventListener('change', updateTimerDuration);

    clearLogBtn.addEventListener('click', () => {
      logContainer.innerHTML = '';
      log('Log cleared', 'info');
    });

    document.getElementById('muteBtn').addEventListener('click', () => {
      toggleMute();
    });

    // Initialize
    loadTimerDuration();
    updateMusicStatus();
    
    log('üéÆ SoilSymphony TURBO MODE initialized!', 'info');
    log('üéµ Music plays automatically: WET=432Hz | DRY=Alert | NORMAL=Silent', 'info');
    log('‚è∞ Timer auto-starts when soil becomes dry', 'info');
    log('üöÄ NEW GAME FEATURES: 10 Levels, Power-ups, Lives, Flying Obstacles!', 'info');
    log('üîä Click/tap anywhere to enable audio', 'info');
    
    // Unlock audio on ANY user interaction
    function setupAudioUnlock() {
      unlockAudio();
      updateMusicStatus();
    }
    
    document.addEventListener('click', setupAudioUnlock, { once: true });
    document.addEventListener('touchstart', setupAudioUnlock, { once: true });
    document.addEventListener('keydown', setupAudioUnlock, { once: true });
    
    // Also trigger on connect button
    const originalConnectHandler = connectBtn.onclick;
    connectBtn.addEventListener('click', () => {
      unlockAudio();
      updateMusicStatus();
    }, { once: true });
  </script>
</body>
</html>
